{
    "docs": [
        {
            "location": "/", 
            "text": "HartreeFockBogoliubov.jl Documentation\n\n\n\n\nOverview\n\n\n\n\nInstallation\n\n\nHartreeFockBogoliubov.jl\n is not a registered package. Install it by\n\n\nPkg\n.\nclone\n(\nhttps://github.com/kyungminlee/HartreeFockBogoliubov.jl.git\n)\n\n\nPkg\n.\nbuild\n(\nHartreeFockBogoliubov\n)\n\n\n\n\n\n\n\n\nLicense\n\n\nMIT License\n\nCopyright (c) 2016 Kyungmin Lee\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \nSoftware\n), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "Home"
        }, 
        {
            "location": "/#hartreefockbogoliubovjl-documentation", 
            "text": "", 
            "title": "HartreeFockBogoliubov.jl Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "HartreeFockBogoliubov.jl  is not a registered package. Install it by  Pkg . clone ( https://github.com/kyungminlee/HartreeFockBogoliubov.jl.git )  Pkg . build ( HartreeFockBogoliubov )", 
            "title": "Installation"
        }, 
        {
            "location": "/#license", 
            "text": "MIT License\n\nCopyright (c) 2016 Kyungmin Lee\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the  Software ), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/", 
            "text": "Hartree-Fock-Bogoliubov Theory\n\n\nThis document contains basics of Hartree-Fock-Bogoliubov Theory. We will follow \nGoodman\n.\n\n\n\n\n\n  H =  \\sum_{ij} T_{ij} c_{i}^{*} c_{j}\n     + \\frac{1}{4} \\sum_{ijkl} V_{ijkl} c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n\n\n\n\n\nThe finite-temperature properties of the system described by the above Hamiltonian can be computed using the density matrix\n\n\n\n\n\n\\begin{align}\nD &= \\frac{e^{-\\beta H}}{Z} \\\\\nZ &= \\mathrm{Tr} e^{-\\beta H}\n\\end{align}\n\n\n\n\n\nIn Hartree-Fock-Bogoliubov theory, we approximate the Hamiltonian $H$ by a non-interacting Hamiltonian of \"quasiparticles\"\n\n\n\n\n\nH_{\\text{HFB}} = E_0 + \\sum_{n} E_{n} a_{n}^{*} a_{n}\n\n\n\n\n\nThe quasiparticle operator $a$ is related to $c$ in the following way:\n\n\n\n\n\nc_{i} = \\sum_{n} \\left( U_{in} a_{n} + V_{in} a_{n}^{*} \\right)\n\n\n\n\n\nThe HFB density matrix is given by\n\n\n\n\n\n\\begin{align}\n  D_{\\text{HFB}} &= \\frac{1}{Z_{\\text{HFB}}} e^{-\\beta \\sum_{n} E_{n} \\hat{n}_{n} } \\\\\n  Z_{\\text{HFB}} &= \\mathrm{Tr} e^{-\\beta \\sum_{n} E_{n} \\hat{n}_{n} }\n\\end{align}\n\n\n\n\n\nwhere\n\n\n\n\n\n\\hat{n}_{n} = a_{n}^{*} a_{n}\n\n\n\n\n\nis the quasiparticle number operator.\n\n\nThe HFB partition function can be calculated:\n\n\n\n\n\nZ_{\\text{HFB}} = \\prod_{n} \\left( 1 + e^{-\\beta E_{n}} \\right)\n\n\n\n\n\nand the density matrix is given in terms of the quasiparticle number operator\n\n\n\n\n\nD_{\\text{HFB}} = Z_{\\text{HFB}}^{-1}\n\\prod_{n}\n\\left[\n  e^{-\\beta E_{n}} \\hat{n}_{n} + (1 - \\hat{n}_{n})\n\\right]\n= \\prod_{n} \\left[ f_{n} \\hat{n}_{n} + (1-f_{n}) (1 - \\hat{n}_{n}) \\right]\n\n\n\n\n\nwhere\n\n\n\n\n\nf_{n} = \\frac{1}{1 + e^{\\beta E_{n}}}\n\n\n\n\n\nis the Fermi-Dirac distribution function for the nth quasiparticle\n\n\nSingle-quasparticle density matrix $\\overline{\\rho}$  and pairing tensor $\\overline{t}$\n\n\n\n\n\n\\begin{align}\n\\overline{\\rho}_{ij}\n  &= \\left\\langle a_{j}^{*} a_{i} \\right\\rangle\n   = \\mathrm{Tr} \\left( D a_{j}^{*} a_{i} \\right) \\\\\n\\overline{t}_{ij}\n  &= \\left\\langle a_{j} a_{i} \\right\\rangle\n   = \\mathrm{Tr} \\left( D a_{j} a_{i} \\right)\n\\end{align}\n\n\n\n\n\nWithin HFB,\n\n\n\n\n\n\\begin{align}\n  \\overline{\\rho}_{ij} = \\delta_{ij} f_{i} \\\\\n  \\overline{t}_{ij} = 0\n\\end{align}\n\n\n\n\n\nThe single-particle density matrix and pairing tensor are\n\n\n\n\n\n\\begin{align}\n\\rho_{ij}\n  &= \\left\\langle c_{j}^{*} c_{i} \\right\\rangle\n  = \\mathrm{Tr} \\left( D c_{j}^{*} c_{i} \\right) \\\\\nt_{ij}\n  &= \\left\\langle c_{j} c_{i} \\right\\rangle\n  = \\mathrm{Tr} \\left( D c_{j} c_{i} \\right)\n\\end{align}\n\n\n\n\n\n\n\n\n\\begin{align}\n  \\rho &= U f U^{\\dagger} + V (1-f) V^{\\dagger} \\\\\n  t    &= U f V^{\\intercal} + V (1-f) U^{\\intercal}\n\\end{align}\n\n\n\n\n\nwhere $f_{ij} = \\delta_{ij} f_{i}$.\n\n\n\n\nExpectation Values\n\n\nWick's theorem\n\n\n\n\n\n\\left\\langle c_{i}^{*} c_{j}^{*} c_{l} c_{k} \\right\\rangle\n=\n\\left\\langle c_{i}^{*} c_{k} \\right\\rangle\n\\left\\langle c_{j}^{*} c_{l} \\right\\rangle\n- \\left\\langle c_{i}^{*} c_{l} \\right\\rangle\n\\left\\langle c_{j}^{*} c_{k} \\right\\rangle\n+ \\left\\langle c_{i}^{*} c_{j}^{*} \\right\\rangle\n\\left\\langle c_{l} c_{k} \\right\\rangle\n\n\n\n\n\n\n\n\n\\begin{align}\nE &= \\mathrm{tr}\n\\left[\n  \\left( T + \\frac{1}{2} \\Gamma \\right) \\rho + \\frac{1}{2} \\Delta t^{\\dagger}\n\\right] \\\\\nS &= - k_B \\sum_{i} \\left[ f_{i} \\ln f_{i} + (1-f_{i}) \\ln (1-f_i)\\right] \\\\\nN &= \\mathrm{tr} \\rho\n\\end{align}\n\n\n\n\n\n\n\n\n\\begin{align}\n\\Gamma_{ij} = \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n\\Delta_{ij} = \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl} \\\\\n\\end{align}\n\n\n\n\n\nThe grand potential\n\n\n\n\n\n\\Omega\n= \\sum_{ij} (T - \\mu)_{ij} \\rho_{ji}\n+ \\frac{1}{2} \\sum_{ijkl} V_{ijkl} \\rho_{lj} \\rho_{ki}\n+ \\frac{1}{4} \\sum_{ijkl} V_{ijkl} t_{ij}^{*} t_{kl}\n+ k_B T \\sum_{i} \\left[ f_{i} \\ln f_{i} + (1-f_{i}) \\ln (1-f_i)\\right]", 
            "title": "Hartree-Fock-Bogoliubov Theory"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#hartree-fock-bogoliubov-theory", 
            "text": "This document contains basics of Hartree-Fock-Bogoliubov Theory. We will follow  Goodman .   \n  H =  \\sum_{ij} T_{ij} c_{i}^{*} c_{j}\n     + \\frac{1}{4} \\sum_{ijkl} V_{ijkl} c_{i}^{*} c_{j}^{*} c_{l} c_{k}   The finite-temperature properties of the system described by the above Hamiltonian can be computed using the density matrix   \n\\begin{align}\nD &= \\frac{e^{-\\beta H}}{Z} \\\\\nZ &= \\mathrm{Tr} e^{-\\beta H}\n\\end{align}   In Hartree-Fock-Bogoliubov theory, we approximate the Hamiltonian $H$ by a non-interacting Hamiltonian of \"quasiparticles\"   \nH_{\\text{HFB}} = E_0 + \\sum_{n} E_{n} a_{n}^{*} a_{n}   The quasiparticle operator $a$ is related to $c$ in the following way:   \nc_{i} = \\sum_{n} \\left( U_{in} a_{n} + V_{in} a_{n}^{*} \\right)   The HFB density matrix is given by   \n\\begin{align}\n  D_{\\text{HFB}} &= \\frac{1}{Z_{\\text{HFB}}} e^{-\\beta \\sum_{n} E_{n} \\hat{n}_{n} } \\\\\n  Z_{\\text{HFB}} &= \\mathrm{Tr} e^{-\\beta \\sum_{n} E_{n} \\hat{n}_{n} }\n\\end{align}   where   \n\\hat{n}_{n} = a_{n}^{*} a_{n}   is the quasiparticle number operator.  The HFB partition function can be calculated:   \nZ_{\\text{HFB}} = \\prod_{n} \\left( 1 + e^{-\\beta E_{n}} \\right)   and the density matrix is given in terms of the quasiparticle number operator   \nD_{\\text{HFB}} = Z_{\\text{HFB}}^{-1}\n\\prod_{n}\n\\left[\n  e^{-\\beta E_{n}} \\hat{n}_{n} + (1 - \\hat{n}_{n})\n\\right]\n= \\prod_{n} \\left[ f_{n} \\hat{n}_{n} + (1-f_{n}) (1 - \\hat{n}_{n}) \\right]   where   \nf_{n} = \\frac{1}{1 + e^{\\beta E_{n}}}   is the Fermi-Dirac distribution function for the nth quasiparticle  Single-quasparticle density matrix $\\overline{\\rho}$  and pairing tensor $\\overline{t}$   \n\\begin{align}\n\\overline{\\rho}_{ij}\n  &= \\left\\langle a_{j}^{*} a_{i} \\right\\rangle\n   = \\mathrm{Tr} \\left( D a_{j}^{*} a_{i} \\right) \\\\\n\\overline{t}_{ij}\n  &= \\left\\langle a_{j} a_{i} \\right\\rangle\n   = \\mathrm{Tr} \\left( D a_{j} a_{i} \\right)\n\\end{align}   Within HFB,   \n\\begin{align}\n  \\overline{\\rho}_{ij} = \\delta_{ij} f_{i} \\\\\n  \\overline{t}_{ij} = 0\n\\end{align}   The single-particle density matrix and pairing tensor are   \n\\begin{align}\n\\rho_{ij}\n  &= \\left\\langle c_{j}^{*} c_{i} \\right\\rangle\n  = \\mathrm{Tr} \\left( D c_{j}^{*} c_{i} \\right) \\\\\nt_{ij}\n  &= \\left\\langle c_{j} c_{i} \\right\\rangle\n  = \\mathrm{Tr} \\left( D c_{j} c_{i} \\right)\n\\end{align}    \n\\begin{align}\n  \\rho &= U f U^{\\dagger} + V (1-f) V^{\\dagger} \\\\\n  t    &= U f V^{\\intercal} + V (1-f) U^{\\intercal}\n\\end{align}   where $f_{ij} = \\delta_{ij} f_{i}$.", 
            "title": "Hartree-Fock-Bogoliubov Theory"
        }, 
        {
            "location": "/basics/hartreefockbogoliubov/#expectation-values", 
            "text": "Wick's theorem   \n\\left\\langle c_{i}^{*} c_{j}^{*} c_{l} c_{k} \\right\\rangle\n=\n\\left\\langle c_{i}^{*} c_{k} \\right\\rangle\n\\left\\langle c_{j}^{*} c_{l} \\right\\rangle\n- \\left\\langle c_{i}^{*} c_{l} \\right\\rangle\n\\left\\langle c_{j}^{*} c_{k} \\right\\rangle\n+ \\left\\langle c_{i}^{*} c_{j}^{*} \\right\\rangle\n\\left\\langle c_{l} c_{k} \\right\\rangle    \n\\begin{align}\nE &= \\mathrm{tr}\n\\left[\n  \\left( T + \\frac{1}{2} \\Gamma \\right) \\rho + \\frac{1}{2} \\Delta t^{\\dagger}\n\\right] \\\\\nS &= - k_B \\sum_{i} \\left[ f_{i} \\ln f_{i} + (1-f_{i}) \\ln (1-f_i)\\right] \\\\\nN &= \\mathrm{tr} \\rho\n\\end{align}    \n\\begin{align}\n\\Gamma_{ij} = \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n\\Delta_{ij} = \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl} \\\\\n\\end{align}   The grand potential   \n\\Omega\n= \\sum_{ij} (T - \\mu)_{ij} \\rho_{ji}\n+ \\frac{1}{2} \\sum_{ijkl} V_{ijkl} \\rho_{lj} \\rho_{ki}\n+ \\frac{1}{4} \\sum_{ijkl} V_{ijkl} t_{ij}^{*} t_{kl}\n+ k_B T \\sum_{i} \\left[ f_{i} \\ln f_{i} + (1-f_{i}) \\ln (1-f_i)\\right]", 
            "title": "Expectation Values"
        }, 
        {
            "location": "/basics/hfbequation/", 
            "text": "HFB Equations\n\n\n\n\n\n\\delta \\Omega = 0", 
            "title": "Hartree-Fock-Bogoliubov Equations"
        }, 
        {
            "location": "/basics/hfbequation/#hfb-equations", 
            "text": "\\delta \\Omega = 0", 
            "title": "HFB Equations"
        }, 
        {
            "location": "/basics/hfbdecomposition/", 
            "text": "Hartree-Fock-Bogoliubov Decomposition\n\n\nWe can write the Hamiltonian in the way that makes the Hermiticity manifest, taking into account duplicates properly\n\n\n\n\n\n\\begin{align}\nH &= \\sum_{ij} T_{ij} c_{i}^{*} c_{j}\n + \\frac{1}{4} \\sum_{ijkl} c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n\\\\\n  &= \\sum_{i} T_{ii} c_{i}^{*} c_{i}\n    + \\sum_{i \\lt j} (T_{ij} c_{i}^{*} c_{j} + T_{ij}^{*} c_{j}^{*} c_{i}) \\\\\n  &\\quad\n  + \\frac{1}{4} \\sum_{i < j}\n  \\left[\n      V_{ijij} c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n    - V_{ijij} c_{j}^{*} c_{i}^{*} c_{j} c_{i}\n    - V_{ijij} c_{i}^{*} c_{j}^{*} c_{i} c_{j}\n    + V_{ijij} c_{j}^{*} c_{i}^{*} c_{i} c_{j}\n  \\right]\n  \\\\\n  &\\quad\n  + \\frac{1}{4} \\sum_{\\substack{(i<j), (k<l) \\\\ \\text{ and } \\\\ (i,j) < (k,l) }}\n  \\left[\n      V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n    - V_{ijkl}     c_{j}^{*} c_{i}^{*} c_{l} c_{k}\n    - V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{k} c_{l}\n    + V_{ijkl}     c_{j}^{*} c_{i}^{*} c_{k} c_{l} \\right.\\\\\n  &\\qquad \\left.\n    + V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n    - V_{ijkl}^{*} c_{l}^{*} c_{k}^{*} c_{j} c_{i}\n    - V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{i} c_{j}\n    + V_{ijkl}^{*} c_{l}^{*} c_{k}^{*} c_{i} c_{j}\n  \\right]\n\\\\\n&= \\sum_{i} T_{ii} c_{i}^{*} c_{i}\n  + \\sum_{i \\lt j} (T_{ij} c_{i}^{*} c_{j} + T_{ij}^{*} c_{j}^{*} c_{i}) \\\\\n&\\quad\n  + \\sum_{i < j}\n  \\left[\n      V_{ijij} c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n  \\right]\n  + \\sum_{\\substack{(i<j), (k<l) \\\\ \\text{ and } \\\\ (i,j) < (k,l) }}\n  \\left[\n      V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n    + V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n  \\right]\n\\end{align}\n\n\n\n\n\n\n\n\n\\begin{align}\n  \\Gamma_{ij} &= \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n  \\Gamma_{ik} &= \\sum_{jl} V_{ijkl} \\rho_{lj} \\\\\n  \\Delta_{ij} &= \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl}\n\\end{align}\n\n\n\n\n\n\n\nDiagonal Interaction\n\n\nLet us first consider the \ndiagonal\n interaction of the form\n\n\n\n\n\n  V c_{1}^{*} c_{2}^{*} c_{2} c_{1} ,\n\n\n\n\n\nwhich is the Hermitian conjugate of itself. Following [Goodman][Goodman80], this interaction decomposes into the following mean fields in the particle-hole and particle-particle channels:\n\n\n\n\n\n\n\n\nInteraction\n\n\nPH Channel\n\n\nPP Channel\n\n\n\n\n\n\n\n\n\n\nV(1212) =  V\n\n\n\u0393(11) =  V \u03c1(22)\n\n\n\u0394(12) =  \u00bd V t(12)\n\n\n\n\n\n\nV(1221) = -V\n\n\n\u0393(12) = -V \u03c1(12)\n\n\n\u0394(12) = -\u00bd V t(21)\n\n\n\n\n\n\nV(2112) = -V\n\n\n\u0393(21) = -V \u03c1(21)\n\n\n\u0394(21) = -\u00bd V t(12)\n\n\n\n\n\n\nV(2121) =  V\n\n\n\u0393(22) =  V \u03c1(11)\n\n\n\u0394(21) =  \u00bd V t(21)\n\n\n\n\n\n\n\n\nHere, the equal sign '=' does not indicate equality. Rather, it refers to the contribution of the right hand side to the mean field on the left hand side. Some of the mean fields are redundant, as required by the Hermiticity of the Hamiltonian. Overall, we end up with\n\n\n\n\n\n\\begin{align}\n\\Gamma_{11} &=  V \\rho_{22} \\\\\n\\Gamma_{12} &= -V \\rho_{12} \\\\\n\\Gamma_{22} &=  V \\rho_{11}\n\\end{align}\n\n\n\n\n\nin the particle-hole channel, and\n\n\n\n\n\n\\begin{align}\n\\Delta_{12} =  V t_{12}\n\\end{align}\n\n\n\n\n\nin the particle-particle channel.\n\n\n\n\nOffdiagonal Interaction\n\n\nNow let us consider the \noffdiagonal\n interaction term of the form\n\n\n\n\n\n  V c_{1}^{*} c_{2}^{*} c_{4} c_{3}.\n\n\n\n\n\nGiven this term in the interaction, it is implied that its Hermitian conjugate\n\n\n\n\n\n  V^{*} c_{3}^{*} c_{4}^{*} c_{2} c_{1}.\n\n\n\n\n\nis also included in the Hamiltonian. The two terms (the explicit term and its Hermitian conjugate) decomposes into\n\n\n\n\n\n\n\n\nInteraction\n\n\nPH Channel\n\n\nPP-Channel\n\n\n\n\n\n\n\n\n\n\nV(1234) =  V\n\n\n\u0393(13) =  V \u03c1(42)\n\n\n\u0394(12) =  \u00bd V t(34)\n\n\n\n\n\n\nV(1243) = -V\n\n\n\u0393(14) = -V \u03c1(32)\n\n\n\u0394(12) = -\u00bd V t(43)\n\n\n\n\n\n\nV(2134) = -V\n\n\n\u0393(23) = -V \u03c1(41)\n\n\n\u0394(21) = -\u00bd V t(34)\n\n\n\n\n\n\nV(2143) =  V\n\n\n\u0393(24) =  V \u03c1(31)\n\n\n\u0394(21) =  \u00bd V t(43)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nV(3412) =  V*\n\n\n\u0393(31) =  V \u03c1(24)\n\n\n\u0394(34) =  \u00bd V t(12)\n\n\n\n\n\n\nV(3421) = -V*\n\n\n\u0393(32) = -V \u03c1(14)\n\n\n\u0394(34) = -\u00bd V t(21)\n\n\n\n\n\n\nV(4312) = -V*\n\n\n\u0393(41) = -V \u03c1(23)\n\n\n\u0394(43) = -\u00bd V t(12)\n\n\n\n\n\n\nV(4321) =  V*\n\n\n\u0393(42) =  V \u03c1(13)\n\n\n\u0394(43) =  \u00bd V t(21)\n\n\n\n\n\n\n\n\nAs we have mentioned above for the diagonal interaction terms, this table contains redundant mean fields. Overwall. we have\n\n\n\n\n\n\\begin{align}\n\\Gamma_{13} &=  V  \\rho_{24}^* \\\\\n\\Gamma_{14} &= -V  \\rho_{23}^* \\\\\n\\Gamma_{23} &= -V  \\rho_{14}^* \\\\\n\\Gamma_{24} &=  V  \\rho_{13}^*\n\\end{align}\n\n\n\n\n\nin the particle-hole channel and\n\n\n\n\n\n\\begin{align}\n\\Delta_{12} &=  V   t_{34} \\\\\n\\Delta_{34} &=  V^* t_{12}\n\\end{align}\n\n\n\n\n\nin the particle-particle channel.", 
            "title": "Hartree-Fock-Bogoliubov Decomposition"
        }, 
        {
            "location": "/basics/hfbdecomposition/#hartree-fock-bogoliubov-decomposition", 
            "text": "We can write the Hamiltonian in the way that makes the Hermiticity manifest, taking into account duplicates properly   \n\\begin{align}\nH &= \\sum_{ij} T_{ij} c_{i}^{*} c_{j}\n + \\frac{1}{4} \\sum_{ijkl} c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n\\\\\n  &= \\sum_{i} T_{ii} c_{i}^{*} c_{i}\n    + \\sum_{i \\lt j} (T_{ij} c_{i}^{*} c_{j} + T_{ij}^{*} c_{j}^{*} c_{i}) \\\\\n  &\\quad\n  + \\frac{1}{4} \\sum_{i < j}\n  \\left[\n      V_{ijij} c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n    - V_{ijij} c_{j}^{*} c_{i}^{*} c_{j} c_{i}\n    - V_{ijij} c_{i}^{*} c_{j}^{*} c_{i} c_{j}\n    + V_{ijij} c_{j}^{*} c_{i}^{*} c_{i} c_{j}\n  \\right]\n  \\\\\n  &\\quad\n  + \\frac{1}{4} \\sum_{\\substack{(i<j), (k<l) \\\\ \\text{ and } \\\\ (i,j) < (k,l) }}\n  \\left[\n      V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n    - V_{ijkl}     c_{j}^{*} c_{i}^{*} c_{l} c_{k}\n    - V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{k} c_{l}\n    + V_{ijkl}     c_{j}^{*} c_{i}^{*} c_{k} c_{l} \\right.\\\\\n  &\\qquad \\left.\n    + V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n    - V_{ijkl}^{*} c_{l}^{*} c_{k}^{*} c_{j} c_{i}\n    - V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{i} c_{j}\n    + V_{ijkl}^{*} c_{l}^{*} c_{k}^{*} c_{i} c_{j}\n  \\right]\n\\\\\n&= \\sum_{i} T_{ii} c_{i}^{*} c_{i}\n  + \\sum_{i \\lt j} (T_{ij} c_{i}^{*} c_{j} + T_{ij}^{*} c_{j}^{*} c_{i}) \\\\\n&\\quad\n  + \\sum_{i < j}\n  \\left[\n      V_{ijij} c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n  \\right]\n  + \\sum_{\\substack{(i<j), (k<l) \\\\ \\text{ and } \\\\ (i,j) < (k,l) }}\n  \\left[\n      V_{ijkl}     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n    + V_{ijkl}^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n  \\right]\n\\end{align}    \n\\begin{align}\n  \\Gamma_{ij} &= \\sum_{kl} V_{ikjl} \\rho_{lk} \\\\\n  \\Gamma_{ik} &= \\sum_{jl} V_{ijkl} \\rho_{lj} \\\\\n  \\Delta_{ij} &= \\frac{1}{2} \\sum_{kl} V_{ijkl} t_{kl}\n\\end{align}", 
            "title": "Hartree-Fock-Bogoliubov Decomposition"
        }, 
        {
            "location": "/basics/hfbdecomposition/#diagonal-interaction", 
            "text": "Let us first consider the  diagonal  interaction of the form   \n  V c_{1}^{*} c_{2}^{*} c_{2} c_{1} ,   which is the Hermitian conjugate of itself. Following [Goodman][Goodman80], this interaction decomposes into the following mean fields in the particle-hole and particle-particle channels:     Interaction  PH Channel  PP Channel      V(1212) =  V  \u0393(11) =  V \u03c1(22)  \u0394(12) =  \u00bd V t(12)    V(1221) = -V  \u0393(12) = -V \u03c1(12)  \u0394(12) = -\u00bd V t(21)    V(2112) = -V  \u0393(21) = -V \u03c1(21)  \u0394(21) = -\u00bd V t(12)    V(2121) =  V  \u0393(22) =  V \u03c1(11)  \u0394(21) =  \u00bd V t(21)     Here, the equal sign '=' does not indicate equality. Rather, it refers to the contribution of the right hand side to the mean field on the left hand side. Some of the mean fields are redundant, as required by the Hermiticity of the Hamiltonian. Overall, we end up with   \n\\begin{align}\n\\Gamma_{11} &=  V \\rho_{22} \\\\\n\\Gamma_{12} &= -V \\rho_{12} \\\\\n\\Gamma_{22} &=  V \\rho_{11}\n\\end{align}   in the particle-hole channel, and   \n\\begin{align}\n\\Delta_{12} =  V t_{12}\n\\end{align}   in the particle-particle channel.", 
            "title": "Diagonal Interaction"
        }, 
        {
            "location": "/basics/hfbdecomposition/#offdiagonal-interaction", 
            "text": "Now let us consider the  offdiagonal  interaction term of the form   \n  V c_{1}^{*} c_{2}^{*} c_{4} c_{3}.   Given this term in the interaction, it is implied that its Hermitian conjugate   \n  V^{*} c_{3}^{*} c_{4}^{*} c_{2} c_{1}.   is also included in the Hamiltonian. The two terms (the explicit term and its Hermitian conjugate) decomposes into     Interaction  PH Channel  PP-Channel      V(1234) =  V  \u0393(13) =  V \u03c1(42)  \u0394(12) =  \u00bd V t(34)    V(1243) = -V  \u0393(14) = -V \u03c1(32)  \u0394(12) = -\u00bd V t(43)    V(2134) = -V  \u0393(23) = -V \u03c1(41)  \u0394(21) = -\u00bd V t(34)    V(2143) =  V  \u0393(24) =  V \u03c1(31)  \u0394(21) =  \u00bd V t(43)         V(3412) =  V*  \u0393(31) =  V \u03c1(24)  \u0394(34) =  \u00bd V t(12)    V(3421) = -V*  \u0393(32) = -V \u03c1(14)  \u0394(34) = -\u00bd V t(21)    V(4312) = -V*  \u0393(41) = -V \u03c1(23)  \u0394(43) = -\u00bd V t(12)    V(4321) =  V*  \u0393(42) =  V \u03c1(13)  \u0394(43) =  \u00bd V t(21)     As we have mentioned above for the diagonal interaction terms, this table contains redundant mean fields. Overwall. we have   \n\\begin{align}\n\\Gamma_{13} &=  V  \\rho_{24}^* \\\\\n\\Gamma_{14} &= -V  \\rho_{23}^* \\\\\n\\Gamma_{23} &= -V  \\rho_{14}^* \\\\\n\\Gamma_{24} &=  V  \\rho_{13}^*\n\\end{align}   in the particle-hole channel and   \n\\begin{align}\n\\Delta_{12} &=  V   t_{34} \\\\\n\\Delta_{34} &=  V^* t_{12}\n\\end{align}   in the particle-particle channel.", 
            "title": "Offdiagonal Interaction"
        }, 
        {
            "location": "/basics/momentumspace/", 
            "text": "Momentum Space Formulation\n\n\n\n\nHopping Elements\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})\n\n\n\n\n\nPairing Elements\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}^{*}(-\\mathbf{k})\n\n\n\n\n\n\n\n\n\\sum_{\\mathbf{R}}\n    c_{\\alpha}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}(-\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})\n\n\n\n\n\n\n\nExpectation Values\n\n\n\n\n\n\\rho_{\\alpha \\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta} - \\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n       f(\\epsilon_n) U_{\\alpha n} U_{\\beta n}^{*}\n\n\n\n\n\n\n\n\nt_{\\alpha\\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}_\\alpha, \\mathbf{k}_\\beta}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta}\n                        -\\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n        f(\\epsilon_n )\n        U_{\\alpha n}\n        V_{\\beta n}^{*}\n\n\n\n\n\n\n\nGrand Potential\n\n\n\n\n\nE = \\mathrm{tr} \\left[ \\left( T + \\frac{1}{2} \\Gamma \\right) \\rho + \\frac{1}{2} \\Delta t^{\\dagger} \\right]\n  = E_{T} + E_{\\Gamma} + E_{\\Delta}\n\n\n\n\n\nwhere\n\n\n\n\n\n\\begin{align}\nE_{T} &= \\mathrm{tr} \\left( T \\rho \\right) \\\\\nE_{\\Gamma} &= \\frac{1}{2} \\mathrm{tr} \\left( \\Gamma \\rho        \\right) \\\\\nE_{\\Delta} &= \\frac{1}{2} \\mathrm{tr} \\left( \\Delta t^{\\dagger} \\right)\n\\end{align}\n\n\n\n\n\nIn momentum space\n\n\n\n\n\n\\begin{align}\nT_{ij}^{\\mathbf{k}} &= T_{ij} e^{i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij}}\n\\rho_{ij} = \\frac{1}{N} \\sum_{\\mathbf{k}} \\rho_{ij}^{\\mathbf{k}} e^{-i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij}}\n\\end{align}\n\n\n\n\n\nThus\n\n\n\n\n\n\\begin{align}\nE_{T}\n  &= \\sum_{ij} T_{ij} \\rho_{ji}\n   = \\sum_{ij} T_{ij}\n     \\frac{1}{N} \\sum_{\\mathbf{k}} \\rho_{ji}^{\\mathbf{k}} e^{-i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ji} }\n   = \\frac{1}{N} \\sum_{\\mathbf{k}} \\sum_{ij} T_{ij} e^{i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij} }\n      \\rho_{ji}^{\\mathbf{k}}\n   = \\frac{1}{N} \\sum_{ij}\n      \\sum_{\\mathbf{k}}\n      T_{ij}^{\\mathbf{k}}\n      \\rho_{ji}^{\\mathbf{k}}\n\\end{align}\n\n\n\n\n\nSimilarly for \u0393 and \u0394:\n\n\n\n\n\n\\begin{align}\nE_{\\Gamma}\n  &= \\frac{1}{2} \\frac{1}{N} \\sum_{ij}\n    \\sum_{\\mathbf{k}}\n    \\Gamma_{ij}^{\\mathbf{k}}\n    \\rho_{ji}^{\\mathbf{k}} \\\\\nE_{\\Delta}\n  &= \\frac{1}{2} \\frac{1}{N} \\sum_{ij}\n    \\sum_{\\mathbf{k}}\n    \\Delta_{ij}^{\\mathbf{k}}\n    {t_{ij}^{\\mathbf{k}} }^{*} \\\\\n\\end{align}\n\n\n\n\n\nHere however, \u0393 and \u0394 need to be consistent with \u03c1 and t.", 
            "title": "Momentum Space Formulation"
        }, 
        {
            "location": "/basics/momentumspace/#momentum-space-formulation", 
            "text": "", 
            "title": "Momentum Space Formulation"
        }, 
        {
            "location": "/basics/momentumspace/#hopping-elements", 
            "text": "\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})   Pairing Elements   \n\\sum_{\\mathbf{R}}\n    c_{\\alpha}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}^{*}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}^{*}(\\mathbf{k})\n    c_{\\beta}^{*}(-\\mathbf{k})    \n\\sum_{\\mathbf{R}}\n    c_{\\alpha}(\\mathbf{R} + \\boldsymbol{\\rho}_\\alpha)\n    c_{\\beta}(\\mathbf{R} + \\boldsymbol{\\rho}_\\beta)\n  =\n    \\sum_{\\mathbf{k}}\n    e^{i \\mathbf{k} \\cdot (\\boldsymbol{\\rho}_\\beta - \\boldsymbol{\\rho}_\\alpha)}\n    c_{\\alpha}(-\\mathbf{k})\n    c_{\\beta}(\\mathbf{k})", 
            "title": "Hopping Elements"
        }, 
        {
            "location": "/basics/momentumspace/#expectation-values", 
            "text": "\\rho_{\\alpha \\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta} - \\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n       f(\\epsilon_n) U_{\\alpha n} U_{\\beta n}^{*}    \nt_{\\alpha\\beta}\n  =\n      \\frac{1}{N}\n      \\sum_{\\mathbf{k}_\\alpha, \\mathbf{k}_\\beta}\n      e^{-i \\mathbf{k} \\cdot ( \\boldsymbol{\\rho}_{\\beta}\n                        -\\boldsymbol{\\rho}_{\\alpha} ) }\n      \\sum_{n}\n        f(\\epsilon_n )\n        U_{\\alpha n}\n        V_{\\beta n}^{*}", 
            "title": "Expectation Values"
        }, 
        {
            "location": "/basics/momentumspace/#grand-potential", 
            "text": "E = \\mathrm{tr} \\left[ \\left( T + \\frac{1}{2} \\Gamma \\right) \\rho + \\frac{1}{2} \\Delta t^{\\dagger} \\right]\n  = E_{T} + E_{\\Gamma} + E_{\\Delta}   where   \n\\begin{align}\nE_{T} &= \\mathrm{tr} \\left( T \\rho \\right) \\\\\nE_{\\Gamma} &= \\frac{1}{2} \\mathrm{tr} \\left( \\Gamma \\rho        \\right) \\\\\nE_{\\Delta} &= \\frac{1}{2} \\mathrm{tr} \\left( \\Delta t^{\\dagger} \\right)\n\\end{align}   In momentum space   \n\\begin{align}\nT_{ij}^{\\mathbf{k}} &= T_{ij} e^{i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij}}\n\\rho_{ij} = \\frac{1}{N} \\sum_{\\mathbf{k}} \\rho_{ij}^{\\mathbf{k}} e^{-i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij}}\n\\end{align}   Thus   \n\\begin{align}\nE_{T}\n  &= \\sum_{ij} T_{ij} \\rho_{ji}\n   = \\sum_{ij} T_{ij}\n     \\frac{1}{N} \\sum_{\\mathbf{k}} \\rho_{ji}^{\\mathbf{k}} e^{-i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ji} }\n   = \\frac{1}{N} \\sum_{\\mathbf{k}} \\sum_{ij} T_{ij} e^{i \\mathbf{k} \\cdot \\boldsymbol{\\rho}_{ij} }\n      \\rho_{ji}^{\\mathbf{k}}\n   = \\frac{1}{N} \\sum_{ij}\n      \\sum_{\\mathbf{k}}\n      T_{ij}^{\\mathbf{k}}\n      \\rho_{ji}^{\\mathbf{k}}\n\\end{align}   Similarly for \u0393 and \u0394:   \n\\begin{align}\nE_{\\Gamma}\n  &= \\frac{1}{2} \\frac{1}{N} \\sum_{ij}\n    \\sum_{\\mathbf{k}}\n    \\Gamma_{ij}^{\\mathbf{k}}\n    \\rho_{ji}^{\\mathbf{k}} \\\\\nE_{\\Delta}\n  &= \\frac{1}{2} \\frac{1}{N} \\sum_{ij}\n    \\sum_{\\mathbf{k}}\n    \\Delta_{ij}^{\\mathbf{k}}\n    {t_{ij}^{\\mathbf{k}} }^{*} \\\\\n\\end{align}   Here however, \u0393 and \u0394 need to be consistent with \u03c1 and t.", 
            "title": "Grand Potential"
        }, 
        {
            "location": "/basics/topology/", 
            "text": "Topology\n\n\nTopology blah.\n\n\n\n\nChern Number\n\n\nKohmoto\n Haldane \nFukui, Hatsugai, and Suzuki\n\n\n\n\nZ2 Topological Index of a Time-Reversal-Invariant System\n\n\nFu and Kane\n. \nFukui and Hatsugai\n.", 
            "title": "Topological Invariants"
        }, 
        {
            "location": "/basics/topology/#topology", 
            "text": "Topology blah.", 
            "title": "Topology"
        }, 
        {
            "location": "/basics/topology/#chern-number", 
            "text": "Kohmoto  Haldane  Fukui, Hatsugai, and Suzuki", 
            "title": "Chern Number"
        }, 
        {
            "location": "/basics/topology/#z2-topological-index-of-a-time-reversal-invariant-system", 
            "text": "Fu and Kane .  Fukui and Hatsugai .", 
            "title": "Z2 Topological Index of a Time-Reversal-Invariant System"
        }, 
        {
            "location": "/guide/lattice/", 
            "text": "Lattice\n\n\n\n\nCarteCoord and FractCoord\n\n\nCarteCoord\n is simply an alias for \nVector{Float64}\n, which represents the coordinates in the real-space. \nFractCoord\n on the other hand, represents a location in the units of the lattice vectors. For example, \nfc\n in the following code represents a location in two-dimensional space whose \nCarteCoord\n is $2.1 \\mathbf{a}_1 + 3.2 \\mathbf{a}_2$ where $\\mathbf{a}_1$ and $\\mathbf{a}_2$ are lattice vectors.\n\n\nfc = FractCoord([2, 3], [0.1, 0.2])\n\n\n\n\n\nFractCoord\n can also be created in the following ways\n\n\nfc2 = FractCoord([2.3, 3.2])\nfc3 = FractCoord(2)\n\n\n\n\n\nfc2\n is the same as \nfc\n, and \nfc3\n represents origin in two dimensions.\n\n\nFractCoord\n supports the following arithmetic operations\n\n\nfc\n \n=\n \nFractCoord\n([\n2\n,\n \n3\n],\n \n[\n0.1\n,\n \n0.2\n])\n\n\n\nfc\n \n+\n \nfc\n\n\nfc\n \n-\n \nfc\n\n\nfc\n \n+\n \n[\n1\n,\n \n0\n]\n\n\nfc\n \n-\n \n[\n1\n,\n \n0\n]\n\n\n\n\n\n\nConversion between \nCarteCoord\n and \nFractCoord\n:\n\n\nlatticevectors\n \n=\n \n[\n2.0\n \n0.0\n;\n \n0.0\n \n1.0\n]\n\n\n\nfc\n \n=\n \nFractCoord\n([\n2\n,\n \n3\n],\n \n[\n0.1\n,\n \n0.2\n])\n\n\ncc\n \n=\n \nfract2carte\n(\nlatticevectors\n,\n \nfc\n)\n\n\nfc2\n \n=\n \ncarte2fract\n(\nlatticevectors\n,\n \ncc\n)\n\n\n\n\n\n\ncc\n is \n[4.2, 3.2]\n and \nfc \u2248 fc2\n is \ntrue\n.\n\n\n\n\nUnitCell\n\n\nA \nUnitCell\n is defined by lattice vectors and orbitals (orbitals here contain all possible degrees of freedom, such as spin, physical \"orbital\", sublattice, etc.).\n\n\nunitcell\n \n=\n \nnewunitcell\n([\n1.0\n \n0.0\n;\n \n0.0\n \n1.0\n];\n \nOrbitalType\n=\nTuple\n{\nSymbol\n,\n \nSymbol\n})\n\n\naddorbital!\n(\nunitcell\n,\n \n(\n:\nA\n,\n \n:\nUP\n),\n \nFractCoord\n([\n0\n,\n0\n],\n \n[\n0.0\n,\n \n0.0\n]))\n\n\naddorbital!\n(\nunitcell\n,\n \n(\n:\nA\n,\n \n:\nDN\n),\n \nFractCoord\n([\n0\n,\n0\n],\n \n[\n0.0\n,\n \n0.0\n]))", 
            "title": "Lattice"
        }, 
        {
            "location": "/guide/lattice/#lattice", 
            "text": "", 
            "title": "Lattice"
        }, 
        {
            "location": "/guide/lattice/#cartecoord-and-fractcoord", 
            "text": "CarteCoord  is simply an alias for  Vector{Float64} , which represents the coordinates in the real-space.  FractCoord  on the other hand, represents a location in the units of the lattice vectors. For example,  fc  in the following code represents a location in two-dimensional space whose  CarteCoord  is $2.1 \\mathbf{a}_1 + 3.2 \\mathbf{a}_2$ where $\\mathbf{a}_1$ and $\\mathbf{a}_2$ are lattice vectors.  fc = FractCoord([2, 3], [0.1, 0.2])  FractCoord  can also be created in the following ways  fc2 = FractCoord([2.3, 3.2])\nfc3 = FractCoord(2)  fc2  is the same as  fc , and  fc3  represents origin in two dimensions.  FractCoord  supports the following arithmetic operations  fc   =   FractCoord ([ 2 ,   3 ],   [ 0.1 ,   0.2 ])  fc   +   fc  fc   -   fc  fc   +   [ 1 ,   0 ]  fc   -   [ 1 ,   0 ]   Conversion between  CarteCoord  and  FractCoord :  latticevectors   =   [ 2.0   0.0 ;   0.0   1.0 ]  fc   =   FractCoord ([ 2 ,   3 ],   [ 0.1 ,   0.2 ])  cc   =   fract2carte ( latticevectors ,   fc )  fc2   =   carte2fract ( latticevectors ,   cc )   cc  is  [4.2, 3.2]  and  fc \u2248 fc2  is  true .", 
            "title": "CarteCoord and FractCoord"
        }, 
        {
            "location": "/guide/lattice/#unitcell", 
            "text": "A  UnitCell  is defined by lattice vectors and orbitals (orbitals here contain all possible degrees of freedom, such as spin, physical \"orbital\", sublattice, etc.).  unitcell   =   newunitcell ([ 1.0   0.0 ;   0.0   1.0 ];   OrbitalType = Tuple { Symbol ,   Symbol })  addorbital! ( unitcell ,   ( : A ,   : UP ),   FractCoord ([ 0 , 0 ],   [ 0.0 ,   0.0 ]))  addorbital! ( unitcell ,   ( : A ,   : DN ),   FractCoord ([ 0 , 0 ],   [ 0.0 ,   0.0 ]))", 
            "title": "UnitCell"
        }, 
        {
            "location": "/guide/hamiltonian/", 
            "text": "Hamiltonian: Full Interacting Hamiltonian\n\n\n\n\nTerms of Hamiltonian\n\n\nHartreeFockBogoliubov.jl\n currently supports Hamiltonian with hopping and (quartic) interaction terms. The hopping terms can be grouped into \"diagonal\" terms and \"offdiagonal\" terms:\n\n\n\n\n\n\\begin{align}\nH_{\\text{diagonal-hopping}} &= \\sum_{i} t_{ii} c_{i}^{*} c_{i} \\\\\nH_{\\text{offdiagonal-hopping}} &= \\sum_{i \\neq j} t_{ij} c_{i}^{*} c_{j}\n\\end{align}\n\n\n\n\n\nThe hermiticity of the Hamiltonian requires that $t_{ii}$ be real, and $t_{ij} = t_{ji}^{*}$. Thus we can rewrite the offdiagonal term as\n\n\n\n\n\nH_{\\text{offdiagonal-hopping}} = \\sum_{i \\lt j} t_{ij} c_{i}^{*} c_{j} + t_{ij}^{*} c_{j}^{*} c_{i}\n\n\n\n\n\nTo incorporate this we define two \nstruct\ns: \nHoppingDiagonal\n and \nHoppingOffdiagonal\n:\n\n\nstruct\n \nHoppingDiagonal\n{\nR\n:\nReal\n}\n\n    \namplitude\n \n::\nR\n\n    \ni\n \n::\nInt\n\n    \nRi\n \n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\nstruct\n \nHoppingOffdiagonal\n{\nC\n:\nNumber\n}\n\n    \namplitude\n \n::\nC\n\n    \ni\n \n::\nInt\n\n    \nj\n \n::\nInt\n\n    \nRi\n \n::\nVector\n{\nInt\n}\n\n    \nRj\n \n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\n\n\n\ni\n and \nj\n are integers representing the \"index\" of the orbital, and \nRi\n and \nRj\n represents which unitcell they are in. The \"unitcell coordinates\" \nRi\n and \nRj\n are necessary for the representation of the Hamiltonian in the momentum space. A single \nHoppingOffdiagonal\n represents both $t_{ij} c_{i}^{*} c_{j}$ and its hermitian conjugate.\n\n\nSimilarly for the interaction, two structs are defined:\n\n\nstruct\n \nInteractionDiagonal\n{\nR\n:\nReal\n}\n\n    \namplitude\n \n::\nR\n\n    \ni\n \n::\nInt\n\n    \nj\n \n::\nInt\n\n    \nRi\n \n::\nVector\n{\nInt\n}\n\n    \nRj\n \n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\nstruct\n \nInteractionOffdiagonal\n{\nC\n:\nNumber\n}\n\n    \namplitude\n \n::\nC\n\n    \ni\n \n::\nInt\n\n    \nj\n \n::\nInt\n\n    \nk\n \n::\nInt\n\n    \nl\n \n::\nInt\n\n    \nRi\n \n::\nVector\n{\nInt\n}\n\n    \nRj\n \n::\nVector\n{\nInt\n}\n\n    \nRk\n \n::\nVector\n{\nInt\n}\n\n    \nRl\n \n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\n\n\n\nwhich represent\n\n\n\n\n\nU c_{i}^{*} c_{j}^{*} c_{j} c_{i}, \\qquad i \\lt j\n\n\n\n\n\nand\n\n\n\n\n\nU     c_{i}^{*} c_{j}^{*} c_{l} c_{k} +\nU^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}, \\qquad\ni \\lt j \\wedge k \\lt l \\wedge [ i \\lt k \\vee ( i = k \\wedge j \\lt l )]\n\n\n\n\n\nIn other words, (i,j) and (k,l) each need to be in lexicographical order, as well as $(i,j) \n (k,l)$.\n\n\nThe following unions are defined\n\n\nconst\n \nHopping\n \n=\n \nUnion\n{\nHoppingDiagonal\n,\n \nHoppingOffdiagonal\n}\n\n\nconst\n \nInteraction\n \n=\n \nUnion\n{\nInteractionDiagonal\n,\n \nInteractionOffdiagonal\n}\n\n\n\n\n\n\n\n\nFunctions Creating Terms\n\n\nHartreeFockBogoliubov.jl\n provides functions that allows generation of hopping terms and interaction terms from the orbital names and their \nCarteCoord\n: \nhoppingbycarte\n and \ninteractionbycarte\n.\n\n\n\n\nFullHamiltonian\n\n\nThe full interacting Hamiltonian is represented by the \nFullHamiltonian\n class\n\n\nmutable\n \nstruct\n \nFullHamiltonian\n{\nO\n}\n\n    \nunitcell\n \n::\nUnitCell\n{\nO\n}\n\n    \nhoppings\n \n::\nVector\n{\nHopping\n}\n\n    \ninteractions\n \n::\nVector\n{\nInteraction\n}\n\n\nend\n\n\n\n\n\n\naddhopping!\n and \naddinteraction!\n.", 
            "title": "Hamiltonian"
        }, 
        {
            "location": "/guide/hamiltonian/#hamiltonian-full-interacting-hamiltonian", 
            "text": "", 
            "title": "Hamiltonian: Full Interacting Hamiltonian"
        }, 
        {
            "location": "/guide/hamiltonian/#terms-of-hamiltonian", 
            "text": "HartreeFockBogoliubov.jl  currently supports Hamiltonian with hopping and (quartic) interaction terms. The hopping terms can be grouped into \"diagonal\" terms and \"offdiagonal\" terms:   \n\\begin{align}\nH_{\\text{diagonal-hopping}} &= \\sum_{i} t_{ii} c_{i}^{*} c_{i} \\\\\nH_{\\text{offdiagonal-hopping}} &= \\sum_{i \\neq j} t_{ij} c_{i}^{*} c_{j}\n\\end{align}   The hermiticity of the Hamiltonian requires that $t_{ii}$ be real, and $t_{ij} = t_{ji}^{*}$. Thus we can rewrite the offdiagonal term as   \nH_{\\text{offdiagonal-hopping}} = \\sum_{i \\lt j} t_{ij} c_{i}^{*} c_{j} + t_{ij}^{*} c_{j}^{*} c_{i}   To incorporate this we define two  struct s:  HoppingDiagonal  and  HoppingOffdiagonal :  struct   HoppingDiagonal { R : Real } \n     amplitude   :: R \n     i   :: Int \n     Ri   :: Vector { Int }  end  struct   HoppingOffdiagonal { C : Number } \n     amplitude   :: C \n     i   :: Int \n     j   :: Int \n     Ri   :: Vector { Int } \n     Rj   :: Vector { Int }  end   i  and  j  are integers representing the \"index\" of the orbital, and  Ri  and  Rj  represents which unitcell they are in. The \"unitcell coordinates\"  Ri  and  Rj  are necessary for the representation of the Hamiltonian in the momentum space. A single  HoppingOffdiagonal  represents both $t_{ij} c_{i}^{*} c_{j}$ and its hermitian conjugate.  Similarly for the interaction, two structs are defined:  struct   InteractionDiagonal { R : Real } \n     amplitude   :: R \n     i   :: Int \n     j   :: Int \n     Ri   :: Vector { Int } \n     Rj   :: Vector { Int }  end  struct   InteractionOffdiagonal { C : Number } \n     amplitude   :: C \n     i   :: Int \n     j   :: Int \n     k   :: Int \n     l   :: Int \n     Ri   :: Vector { Int } \n     Rj   :: Vector { Int } \n     Rk   :: Vector { Int } \n     Rl   :: Vector { Int }  end   which represent   \nU c_{i}^{*} c_{j}^{*} c_{j} c_{i}, \\qquad i \\lt j   and   \nU     c_{i}^{*} c_{j}^{*} c_{l} c_{k} +\nU^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}, \\qquad\ni \\lt j \\wedge k \\lt l \\wedge [ i \\lt k \\vee ( i = k \\wedge j \\lt l )]   In other words, (i,j) and (k,l) each need to be in lexicographical order, as well as $(i,j)   (k,l)$.  The following unions are defined  const   Hopping   =   Union { HoppingDiagonal ,   HoppingOffdiagonal }  const   Interaction   =   Union { InteractionDiagonal ,   InteractionOffdiagonal }", 
            "title": "Terms of Hamiltonian"
        }, 
        {
            "location": "/guide/hamiltonian/#functions-creating-terms", 
            "text": "HartreeFockBogoliubov.jl  provides functions that allows generation of hopping terms and interaction terms from the orbital names and their  CarteCoord :  hoppingbycarte  and  interactionbycarte .", 
            "title": "Functions Creating Terms"
        }, 
        {
            "location": "/guide/hamiltonian/#fullhamiltonian", 
            "text": "The full interacting Hamiltonian is represented by the  FullHamiltonian  class  mutable   struct   FullHamiltonian { O } \n     unitcell   :: UnitCell { O } \n     hoppings   :: Vector { Hopping } \n     interactions   :: Vector { Interaction }  end   addhopping!  and  addinteraction! .", 
            "title": "FullHamiltonian"
        }, 
        {
            "location": "/guide/hfb/", 
            "text": "HFB: Hartree-Fock-Bogoliubov\n\n\n\n\nHFBComputer\n\n\nHFBComputer\n is a struct which is used to calculate the Hartree-Fock-Bogoliubov Hamiltonian from mean-field parameters, and the parameters from the eigenstates of Hartree-Fock-Bogoliubov Hamiltonian.\n\n\nmutable\n \nstruct\n \nHFBComputer\n{\nO\n}\n\n    \nunitcell\n \n::\nUnitCell\n{\nO\n}\n\n    \nhoppings\n \n::\nVector\n{\nSpec\n.\nHopping\n}\n\n    \ntemperature\n \n::\nFloat64\n\n\n    \nfermi\n \n::\nFunction\n\n    \n\u03c1_registry\n \n::\nVector\n{\nCollectRow\n}\n\n    \nt_registry\n \n::\nVector\n{\nCollectRow\n}\n\n    \n\u0393_registry\n \n::\nVector\n{\nDeployRow\n}\n\n    \n\u0394_registry\n \n::\nVector\n{\nDeployRow\n}\n\n\nend\n\n\n\n\n\n\nThe type \nCollectRow\n keeps record of the \"observables\" that need to be measured in order to calculate the mean-field parameters. They are the \u03c1(i,j) and t(i,j) as defined by Goodman.\n\n\nconst\n \nCollectRow\n \n=\n \nTuple\n{\nBool\n,\n \nInt\n,\n \nInt\n,\n \nVector\n{\nFloat64\n}}\n\n\n\n\n\n\nDeployRow\n contains necessary information to calculate \u0393(i,j) and \u0394(i,j), using the measured \u03c1(i,j) and t(i,j)\n\n\nconst\n \nDeployRow\n \n=\n \nTuple\n{\nBool\n,\n \nInt\n,\n \nInt\n,\n \nVector\n{\nFloat64\n},\n \nVector\n{\nTuple\n{\nInt\n,\n \nComplex\n{\nFloat64\n},\n \nBool\n}}}\n\n\n\n\n\n\n\n\nHFBSolver\n\n\nHFBSolver\n is blah.\n\n\nmutable\n \nstruct\n \nHFBSolver\n{\nO\n}\n\n    \n# Originals\n\n    \nhamiltonian\n \n::\nFullHamiltonian\n{\nO\n}\n\n    \nsize\n \n::\nVector\n{\nInt\n}\n\n    \ntemperature\n \n::\nFloat64\n\n\n    \n# Derivatives\n\n    \nmomentumgrid\n \n::\nArray\n{\nVector\n{\nFloat64\n}}\n\n    \nhfbhamiltonian\n \n::\nHFBHamiltonian\n{\nO\n}\n\n    \nhfbcomputer\n \n::\nHFBComputer\n{\nO\n}\n\n    \ngreencollectors\n \n::\nFunction\n\n\nend\n\n\n\n\n\n\nHFBSolver contains:\n\n\n\n\nThe full interacting Hamiltonian,\n\n\nSize of the system (i.e. number of k-points in the Brillouin zone)\n\n\nTemperature (needed to calculate the \u03c1 and t)\n\n\n\n\nAnd using these properties, BLAH.\n\n\n\n\nUsing HFBSolver to Find Self-Consistent Solution\n\n\nloop\n(\nsolver\n,\n \nsolution\n,\n \n100\n)", 
            "title": "HFB"
        }, 
        {
            "location": "/guide/hfb/#hfb-hartree-fock-bogoliubov", 
            "text": "", 
            "title": "HFB: Hartree-Fock-Bogoliubov"
        }, 
        {
            "location": "/guide/hfb/#hfbcomputer", 
            "text": "HFBComputer  is a struct which is used to calculate the Hartree-Fock-Bogoliubov Hamiltonian from mean-field parameters, and the parameters from the eigenstates of Hartree-Fock-Bogoliubov Hamiltonian.  mutable   struct   HFBComputer { O } \n     unitcell   :: UnitCell { O } \n     hoppings   :: Vector { Spec . Hopping } \n     temperature   :: Float64 \n\n     fermi   :: Function \n     \u03c1_registry   :: Vector { CollectRow } \n     t_registry   :: Vector { CollectRow } \n     \u0393_registry   :: Vector { DeployRow } \n     \u0394_registry   :: Vector { DeployRow }  end   The type  CollectRow  keeps record of the \"observables\" that need to be measured in order to calculate the mean-field parameters. They are the \u03c1(i,j) and t(i,j) as defined by Goodman.  const   CollectRow   =   Tuple { Bool ,   Int ,   Int ,   Vector { Float64 }}   DeployRow  contains necessary information to calculate \u0393(i,j) and \u0394(i,j), using the measured \u03c1(i,j) and t(i,j)  const   DeployRow   =   Tuple { Bool ,   Int ,   Int ,   Vector { Float64 },   Vector { Tuple { Int ,   Complex { Float64 },   Bool }}}", 
            "title": "HFBComputer"
        }, 
        {
            "location": "/guide/hfb/#hfbsolver", 
            "text": "HFBSolver  is blah.  mutable   struct   HFBSolver { O } \n     # Originals \n     hamiltonian   :: FullHamiltonian { O } \n     size   :: Vector { Int } \n     temperature   :: Float64 \n\n     # Derivatives \n     momentumgrid   :: Array { Vector { Float64 }} \n     hfbhamiltonian   :: HFBHamiltonian { O } \n     hfbcomputer   :: HFBComputer { O } \n     greencollectors   :: Function  end   HFBSolver contains:   The full interacting Hamiltonian,  Size of the system (i.e. number of k-points in the Brillouin zone)  Temperature (needed to calculate the \u03c1 and t)   And using these properties, BLAH.", 
            "title": "HFBSolver"
        }, 
        {
            "location": "/guide/hfb/#using-hfbsolver-to-find-self-consistent-solution", 
            "text": "loop ( solver ,   solution ,   100 )", 
            "title": "Using HFBSolver to Find Self-Consistent Solution"
        }, 
        {
            "location": "/guide/linearizedgap/", 
            "text": "LinearizedGap\n\n\nLinearized gap equation. Refer to basics.", 
            "title": "Linearized Gap Equation"
        }, 
        {
            "location": "/guide/linearizedgap/#linearizedgap", 
            "text": "Linearized gap equation. Refer to basics.", 
            "title": "LinearizedGap"
        }, 
        {
            "location": "/guide/topology/", 
            "text": "Topology\n\n\n\n\nChern\n\n\n\n\nZ2\n\n\nZ2 index of time-reversal invariant topological insulator/superconductor.\n\n\nz2index\n(\n...\n)", 
            "title": "Topology"
        }, 
        {
            "location": "/guide/topology/#topology", 
            "text": "", 
            "title": "Topology"
        }, 
        {
            "location": "/guide/topology/#chern", 
            "text": "", 
            "title": "Chern"
        }, 
        {
            "location": "/guide/topology/#z2", 
            "text": "Z2 index of time-reversal invariant topological insulator/superconductor.  z2index ( ... )", 
            "title": "Z2"
        }, 
        {
            "location": "/guide/example/", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/internals/", 
            "text": "Internal Documentation\n\n\nThis page lists all the documented internals of the \nHartreeFockBogoliubov\n module and submodules.\n\n\n\n\nContents\n\n\n\n\nInternals\n\n\nLattice\n\n\nSpec\n\n\nGenerator\n\n\nTopology\n\n\nHFB\n\n\nLinearizedGap\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\nA list of all internal documentation sorted by module.\n\n\n\n\nHartreeFockBogoliubov.Generator\n\n\nHartreeFockBogoliubov.Spec\n\n\nHartreeFockBogoliubov.Spec.Hopping\n\n\nHartreeFockBogoliubov.Spec.Interaction\n\n\nHartreeFockBogoliubov.HFB.CollectRow\n\n\nHartreeFockBogoliubov.HFB.DeployRow\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n\n\nHartreeFockBogoliubov.HFB.HoppingMeanField\n\n\nHartreeFockBogoliubov.HFB.PairingMeanField\n\n\nHartreeFockBogoliubov.Lattice.CarteCoord\n\n\nHartreeFockBogoliubov.Lattice.FractCoord\n\n\nHartreeFockBogoliubov.Lattice.UnitCell\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n\n\nHartreeFockBogoliubov.Spec.HoppingOffdiagonal\n\n\nHartreeFockBogoliubov.Spec.InteractionDiagonal\n\n\nHartreeFockBogoliubov.Spec.InteractionOffdiagonal\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatefast\n\n\nHartreeFockBogoliubov.Generator.generatehoppingfast\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n\n\nHartreeFockBogoliubov.HFB.computetargetfields\n\n\nHartreeFockBogoliubov.HFB.fixhfbsolution\n\n\nHartreeFockBogoliubov.HFB.freeze\n\n\nHartreeFockBogoliubov.HFB.getnextsolution\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionpython\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionthreaded\n\n\nHartreeFockBogoliubov.HFB.isvalidsolution\n\n\nHartreeFockBogoliubov.HFB.loop\n\n\nHartreeFockBogoliubov.HFB.looppython\n\n\nHartreeFockBogoliubov.HFB.loopthreaded\n\n\nHartreeFockBogoliubov.HFB.makeDeltamatrix\n\n\nHartreeFockBogoliubov.HFB.makeGammamatrix\n\n\nHartreeFockBogoliubov.HFB.makegreencollectors\n\n\nHartreeFockBogoliubov.HFB.makehamiltonian\n\n\nHartreeFockBogoliubov.HFB.makehoppingmatrix\n\n\nHartreeFockBogoliubov.HFB.makeparticleholeregistry\n\n\nHartreeFockBogoliubov.HFB.makeparticleparticleregistry\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.nambufy\n\n\nHartreeFockBogoliubov.HFB.newhfbhint\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n\n\nHartreeFockBogoliubov.HFB.randomize!\n\n\nHartreeFockBogoliubov.Lattice.addorbital!\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n\n\nHartreeFockBogoliubov.Lattice.dimension\n\n\nHartreeFockBogoliubov.Lattice.dimension\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindex\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindexcoord\n\n\nHartreeFockBogoliubov.Lattice.getorbitalname\n\n\nHartreeFockBogoliubov.Lattice.hasorbital\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n\n\nHartreeFockBogoliubov.Lattice.numorbital\n\n\nHartreeFockBogoliubov.Lattice.whichunitcell\n\n\nHartreeFockBogoliubov.LinearizedGap.linearizedpairingkernel\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n\n\nHartreeFockBogoliubov.Topology.chernnumber\n\n\nHartreeFockBogoliubov.Topology.getnambuphase\n\n\nHartreeFockBogoliubov.Topology.isvalidtimereversalmatrix\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.squarify\n\n\nHartreeFockBogoliubov.Topology.timereversalindexgrid\n\n\nHartreeFockBogoliubov.Topology.z2index", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internal-documentation", 
            "text": "This page lists all the documented internals of the  HartreeFockBogoliubov  module and submodules.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/internals/#contents", 
            "text": "Internals  Lattice  Spec  Generator  Topology  HFB  LinearizedGap", 
            "title": "Contents"
        }, 
        {
            "location": "/internals/#index", 
            "text": "A list of all internal documentation sorted by module.   HartreeFockBogoliubov.Generator  HartreeFockBogoliubov.Spec  HartreeFockBogoliubov.Spec.Hopping  HartreeFockBogoliubov.Spec.Interaction  HartreeFockBogoliubov.HFB.CollectRow  HartreeFockBogoliubov.HFB.DeployRow  HartreeFockBogoliubov.HFB.HFBComputer  HartreeFockBogoliubov.HFB.HFBComputer  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBHamiltonian  HartreeFockBogoliubov.HFB.HFBSolver  HartreeFockBogoliubov.HFB.HFBSolver  HartreeFockBogoliubov.HFB.HoppingMeanField  HartreeFockBogoliubov.HFB.PairingMeanField  HartreeFockBogoliubov.Lattice.CarteCoord  HartreeFockBogoliubov.Lattice.FractCoord  HartreeFockBogoliubov.Lattice.UnitCell  HartreeFockBogoliubov.Spec.FullHamiltonian  HartreeFockBogoliubov.Spec.FullHamiltonian  HartreeFockBogoliubov.Spec.HoppingDiagonal  HartreeFockBogoliubov.Spec.HoppingDiagonal  HartreeFockBogoliubov.Spec.HoppingOffdiagonal  HartreeFockBogoliubov.Spec.InteractionDiagonal  HartreeFockBogoliubov.Spec.InteractionOffdiagonal  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatefast  HartreeFockBogoliubov.Generator.generatehoppingfast  HartreeFockBogoliubov.HFB.addinteraction!  HartreeFockBogoliubov.HFB.addinteraction!  HartreeFockBogoliubov.HFB.computetargetfields  HartreeFockBogoliubov.HFB.fixhfbsolution  HartreeFockBogoliubov.HFB.freeze  HartreeFockBogoliubov.HFB.getnextsolution  HartreeFockBogoliubov.HFB.getnextsolutionpython  HartreeFockBogoliubov.HFB.getnextsolutionthreaded  HartreeFockBogoliubov.HFB.isvalidsolution  HartreeFockBogoliubov.HFB.loop  HartreeFockBogoliubov.HFB.looppython  HartreeFockBogoliubov.HFB.loopthreaded  HartreeFockBogoliubov.HFB.makeDeltamatrix  HartreeFockBogoliubov.HFB.makeGammamatrix  HartreeFockBogoliubov.HFB.makegreencollectors  HartreeFockBogoliubov.HFB.makehamiltonian  HartreeFockBogoliubov.HFB.makehoppingmatrix  HartreeFockBogoliubov.HFB.makeparticleholeregistry  HartreeFockBogoliubov.HFB.makeparticleparticleregistry  HartreeFockBogoliubov.HFB.makesourcefields  HartreeFockBogoliubov.HFB.makesourcefields  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.nambufy  HartreeFockBogoliubov.HFB.newhfbhint  HartreeFockBogoliubov.HFB.newhfbsolution  HartreeFockBogoliubov.HFB.newhfbsolution  HartreeFockBogoliubov.HFB.randomize!  HartreeFockBogoliubov.Lattice.addorbital!  HartreeFockBogoliubov.Lattice.carte2fract  HartreeFockBogoliubov.Lattice.carte2fract  HartreeFockBogoliubov.Lattice.dimension  HartreeFockBogoliubov.Lattice.dimension  HartreeFockBogoliubov.Lattice.fract2carte  HartreeFockBogoliubov.Lattice.fract2carte  HartreeFockBogoliubov.Lattice.getorbital  HartreeFockBogoliubov.Lattice.getorbital  HartreeFockBogoliubov.Lattice.getorbitalcoord  HartreeFockBogoliubov.Lattice.getorbitalcoord  HartreeFockBogoliubov.Lattice.getorbitalindex  HartreeFockBogoliubov.Lattice.getorbitalindexcoord  HartreeFockBogoliubov.Lattice.getorbitalname  HartreeFockBogoliubov.Lattice.hasorbital  HartreeFockBogoliubov.Lattice.newunitcell  HartreeFockBogoliubov.Lattice.newunitcell  HartreeFockBogoliubov.Lattice.numorbital  HartreeFockBogoliubov.Lattice.whichunitcell  HartreeFockBogoliubov.LinearizedGap.linearizedpairingkernel  HartreeFockBogoliubov.Spec.addhopping!  HartreeFockBogoliubov.Spec.addhopping!  HartreeFockBogoliubov.Spec.addinteraction!  HartreeFockBogoliubov.Spec.addinteraction!  HartreeFockBogoliubov.Spec.hoppingbycarte  HartreeFockBogoliubov.Spec.hoppingbycarte  HartreeFockBogoliubov.Spec.interactionbycarte  HartreeFockBogoliubov.Spec.interactionbycarte  HartreeFockBogoliubov.Topology.chernnumber  HartreeFockBogoliubov.Topology.getnambuphase  HartreeFockBogoliubov.Topology.isvalidtimereversalmatrix  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.squarify  HartreeFockBogoliubov.Topology.timereversalindexgrid  HartreeFockBogoliubov.Topology.z2index", 
            "title": "Index"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/", 
            "text": "Internals\n\n\n\n\nLattice\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.CarteCoord\n \n \nType\n.\n\n\nCarteCoord\n\n\n\n\n\nCartesian coordinates. \nVector{Float64}\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.FractCoord\n \n \nType\n.\n\n\nFractCoord\n\n\n\n\n\nFractional coordinates.\n\n\nMembers\n\n\n\n\nwhole ::Vector{Int}\n: Integer part of fractional coordinates\n\n\nfraction ::Vector{Float64}\n: [0,1) part of fractional coordinates\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.UnitCell\n \n \nType\n.\n\n\nUnitCell{T}\n\n\n\n\n\nMembers\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n: Lattice vectors\n\n\nreducedreciprocallatticevectors ::Array{Float64, 2}\n: Reduced reciprocal lattice vectors (transpose of inverse of \nlatticevectors\n)\n\n\nreciprocallatticevectors ::Array{Float64, 2}\n: Reciprocal lattice vectors\n\n\norbitals ::Vector{Tuple{T, FractCoord}}\n: List of orbitals within unit cell\n\n\norbitalindices ::Dict{T, Int}\n: Indices of orbitals\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.addorbital!\n \n \nMethod\n.\n\n\naddorbital!\n\n\n\n\n\nAdd an orbital to the unit cell.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\norbitalname ::{T}\n\n\norbitalcoord ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n \n \nMethod\n.\n\n\ncarte2fract\n\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\ncc ::CarteCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.carte2fract\n \n \nMethod\n.\n\n\ncarte2fract\n\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\ncc ::CarteCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.dimension\n \n \nMethod\n.\n\n\ndimension\n\n\n\n\n\nDimension of the fractional coordinates\n\n\nArguments\n\n\n\n\nfc ::FractCoord\n: Fractional coordinates.\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.dimension\n \n \nMethod\n.\n\n\ndimension\n\n\n\n\n\nSpatial dimension of the unit cell.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n \n \nMethod\n.\n\n\nfract2carte\n\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\nfc ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.fract2carte\n \n \nMethod\n.\n\n\nfract2carte\n\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n\n\nfc ::FractCoord\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n \n \nMethod\n.\n\n\ngetorbital\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbital\n \n \nMethod\n.\n\n\ngetorbital\n\n\n\n\n\nGet the orbital with the given name.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n \n \nMethod\n.\n\n\ngetorbitalcoord\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalcoord\n \n \nMethod\n.\n\n\ngetorbitalcoord\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindex\n \n \nMethod\n.\n\n\ngetorbitalindex\n\n\n\n\n\nGet index of the given orbital.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalindexcoord\n \n \nMethod\n.\n\n\ngetorbitalindexcoord\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\nname ::T\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.getorbitalname\n \n \nMethod\n.\n\n\ngetorbitalname\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\nidx ::Integer\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.hasorbital\n \n \nMethod\n.\n\n\nhasorbital{T}\n\n\n\n\n\nTest whether the unit cell contains the orbital of given name.\n\n\nArguments\n\n\n\n\nuc ::UnitCell{O}\n\n\nname ::O\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n \n \nMethod\n.\n\n\nUnitCell\n\n\n\n\n\nArguments\n\n\n\n\nlatticevectors ::Array{Float64, 2}\n: Lattice vectors\n\n\nOrbitalType::DataType\n\n\n\n\nOptional Arguments\n\n\n\n\ntol=sqrt(eps(Float64))\n: Epsilon\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.newunitcell\n \n \nMethod\n.\n\n\nUnitCell\n\n\n\n\n\nConstruct a one-dimensional lattice.\n\n\nArguments\n\n\n\n\nlatticeconstant ::Float64\n: Lattice constant\n\n\nOrbitalType\n: List of orbitals\n\n\n\n\nOptional Arguments\n\n\n\n\ntol=sqrt(eps(Float64))\n: Tolerance\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.numorbital\n \n \nMethod\n.\n\n\nnumorbital\n\n\n\n\n\nNumber of orbitals of the unit cell.\n\n\nArguments\n\n\n\n\nuc ::UnitCell\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Lattice.whichunitcell\n \n \nMethod\n.\n\n\nwhichunitcell\n\n\n\n\n\nReturn which unit cell the specificied orbital/cartesian coordinates belongs to.\n\n\nsource\n\n\n\n\nSpec\n\n\n#\n\n\nHartreeFockBogoliubov.Spec\n \n \nModule\n.\n\n\nSubmodule `Spec`\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.Hopping\n \n \nConstant\n.\n\n\nHopping\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.Interaction\n \n \nConstant\n.\n\n\nInteraction\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n \n \nType\n.\n\n\nFullHamiltonian\n\n\n\n\n\nMembers\n\n\n\n\nunitcell ::UnitCell\n\n\nhoppings ::Vector{Hopping}\n\n\ninteractions ::Vector{Interaction}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.FullHamiltonian\n \n \nMethod\n.\n\n\nHamiltonian\n\n\n\n\n\nCreate an empty Hamiltonian\n\n\nArguments\n\n\n\n\nunitcell ::UnitCell\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n \n \nType\n.\n\n\nHoppingDiagonal{R\n:Real}\n\n\n\n\n\nRepresents\n\n\n\n\n\n  t c_{i}^{*} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude ::R\n\n\ni ::Int\n: name of orbital\n\n\nRi ::Vector{Int}\n: which unit cell? (indexed by a1, and a2)\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingDiagonal\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.HoppingOffdiagonal\n \n \nType\n.\n\n\nHoppingOffdiagonal{C\n:Number}\n\n\n\n\n\nRepresents\n\n\n\n\n\n  t c_{i}^{*} c_{j} + t^* c_{j}^{*} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude :: C\n\n\ni ::T\n\n\nj ::T\n\n\nRi ::Vector{Int}\n\n\nRj ::Vector{Int}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.InteractionDiagonal\n \n \nType\n.\n\n\nInteractionDiagonal{R\n:Real}\n\n\n\n\n\nRepresents\n\n\n\n\n\n    U c_{i}^{*} c_{j}^{*} c_{j} c_{i}\n\n\n\n\n\nMembers\n\n\n\n\namplitude ::R\n\n\ni ::T\n\n\nj ::T\n\n\nRi ::Vector{Int}\n\n\nRj ::Vector{Int}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.InteractionOffdiagonal\n \n \nType\n.\n\n\nInteractionOffdiagonal{C\n:Number}\n\ni \n j, k \n l, i \n k or (i == k and j \n l)\n\n\n\n\n\nRepresents\n\n\n\n\n\n   U     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n + U^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}\n\n\n\n\n\nOnly keep the first term (and require i \n j, k \n l, i \n= k)\n\n\nMembers\n\n\n\n\namplitude ::C\n\n\ni ::T\n\n\nj ::T\n\n\nk ::T\n\n\nl ::T\n\n\nRi ::Vector{Int}\n\n\nRj ::Vector{Int}\n\n\nRk ::Vector{Int}\n\n\nRl ::Vector{Int}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n \n \nMethod\n.\n\n\naddhopping!\n\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\nhopping ::HoppingOffdiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addhopping!\n \n \nMethod\n.\n\n\naddhopping!\n\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\nhopping ::HoppingDiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n \n \nMethod\n.\n\n\naddinteraction!\n\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\ninteraction ::InteractionOffdiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.addinteraction!\n \n \nMethod\n.\n\n\naddinteraction!\n\n\n\n\n\nArguments\n\n\n\n\nhamiltonian ::Hamiltonian\n\n\ninteraction ::InteractionDiagonal\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n \n \nMethod\n.\n\n\nhoppingbycarte{T}\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\namplitude ::Number\n\n\ni ::T\n\n\nj ::T\n\n\nri ::CarteCoord\n\n\nrj ::CarteCoord\n\n\ntol ::Real\n : Optional. Defaults to \nsqrt(eps(Float64))\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.hoppingbycarte\n \n \nMethod\n.\n\n\nhoppingbycarte{T}\n\n\n\n\n\nArguments\n\n\n\n\nuc ::UnitCell{T}\n\n\namplitude ::Real\n\n\ni ::T\n\n\nri ::CarteCoord\n\n\ntol ::Real\n : Optional. Defaults to \nsqrt(eps(Float64))\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n \n \nMethod\n.\n\n\ninteractionbycarte{T}\n\n\n\n\n\nArguments\n\n\n* `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `k ::T`\n* `l ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `rk ::CarteCoord`\n* `rl ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Spec.interactionbycarte\n \n \nMethod\n.\n\n\ninteractionbycarte{T}\n\n\n\n\n\nArguments\n\n\n* `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`\n\n\n\n\n\nsource\n\n\n\n\nGenerator\n\n\n#\n\n\nHartreeFockBogoliubov.Generator\n \n \nModule\n.\n\n\nGenerator submodule\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatefast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Generator.generatehoppingfast\n \n \nMethod\n.\n\n\ngeneratefast\n\n\n\n\n\nsource\n\n\n\n\nTopology\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.isvalidtimereversalmatrix\n \n \nMethod\n.\n\n\nisvalidtimereversalmatrix\n\n\n\n\n\nTest whether the given matrix is a valid unitary matrix for the time reversal operation.\n\n\n```math\nT = U \u22c5 K\n```\n\n``U`` must satisfy the two conditions:\n1. ``U U^{\\dagger} = 1`` (from unitarity of ``U``)\n2. ``U = - U^{\\mathsf{T}}`` (from `T^2 = -1`)\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\n\nArguments\n\n\n\n\nuc::Spec.FullHamiltonian{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\n\nArguments\n\n\n\n\nuc::HFB.HFBHamiltonian{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.squarify\n \n \nMethod\n.\n\n\nsquarify\n\n\n\n\n\nIn order to make the Hamiltoinian a periodic function of momentum, bring all the sites to the origin. In addition, make the unitcell into a square.\n\n\nArguments\n\n\n\n\nuc::Lattice.UnitCell{O}\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.timereversalindexgrid\n \n \nMethod\n.\n\n\ngenerate k-space grid (which has (2 n1, 2 n2) points TOTAL in the Brillouin zone)\n\n\nExample\n\n\nWhen n1 = 4, n2 = 3, this function returns an \nOrderedDict\n that represents the following structure\n\n\ni2|\n  |\n5 | -i -i -i -i -i -i -i -i\n4 | -i -i -i -i -i -i -i -i\n3 | 0h +h +h +h 0h -h -h -h\n2 | +i +i +i +i +i +i +i +i\n1 | +i +i +i +i +i +i +i +i\n0 | 0z +z +z +z 0z -z -z -z\n--+----------------------------\n  |  0  1  2  3  4  5  6  7  i1\n\n\n\n\n\nwhere 0z, +z, -z are represented respectively by \n:TRIZERO\n, \n:POSZERO\n, and \n:NEGZERO\n, and   0h, +h, -h by \n:TRIHALF\n, \n:POSHALF\n, and \n:NEGHALF\n, and   +i, -i by \n:POSINT\n, \n:NEGINT\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.chernnumber\n \n \nMethod\n.\n\n\nchernnumber\n\n\n\n\n\nCompute chern number of the band structure defined by the hoppings and the selected bands.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.getnambuphase\n \n \nMethod\n.\n\n\nGet the phase of hamiltonian function.     Returns nan if no phase\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.Topology.z2index\n \n \nMethod\n.\n\n\nz2index\n\n\nCompute Z2 index of time-reversal-invariant Hamiltonian.\n\n\nArguments\n\n\n\n\nuc::UnitCell{O}\n\n\nhops::AbstractVector{Hopping}\n\n\ntimereversal::AbstractMatrix\n\n\nn1 ::Integer\n\n\nn2 ::Integer\n\n\nselectpairs::AbstractVector{\n:Integer}\n\n\n\n\nOptional Arguments\n\n\n\n\ntol ::Real = sqrt(eps(Float64))\n\n\n\n\nReturns\n\n\n(The Z2 index,  max| H\u2096 - T\u207b\u00b9H\u2096T | for k in TRIMs)\n\n\nsource\n\n\n\n\nHFB\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n \n \nType\n.\n\n\nHFBConmputer\n is a type holding the \u03c1, t and \u0393, \u0394 of a Hartree-Fock-Bogoliubov Hamiltonian.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBComputer\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBHamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HFBSolver\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n \n \nMethod\n.\n\n\nAdd offdiagonal interaction\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.addinteraction!\n \n \nMethod\n.\n\n\naddinteraction!\n\n\n\n\n\nAdd diagonal interaction\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.computetargetfields\n \n \nMethod\n.\n\n\nCompute \u0393 and \u0394 from \u03c1 and t.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.fixhfbsolution\n \n \nMethod\n.\n\n\nRecompute \u0393 and \u0394 from \u03c1 and t in a \nHFBSolution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.freeze\n \n \nMethod\n.\n\n\nfreeze\n\nCreate a hopping hamiltonian out of HFB Hamiltonian and Solution\n\nOrder:\nelectrons......, HOLE......\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolution\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionpython\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.getnextsolutionthreaded\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.isvalidsolution\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.loop\n \n \nMethod\n.\n\n\nloop\n\n\n\n\n\nPerform selfconsistency loop a number of times with the given precondition and given update functions.\n\n\nArguments\n\n\n\n\nsolver ::HFBSolver{T}\n\n\nsol::HFBSolution\n\n\nrun::Integer\n\n\n\n\nOptional Arguments\n\n\n\n\nupdate::Function=simpleupdate\n\n\nprecondition::Function=identity\n\n\ncallback::Function=_noop\n: Function called after every update as\n\n\n\n\ncallback(i, run)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.looppython\n \n \nMethod\n.\n\n\nloop\n\n\n\n\n\nPerform selfconsistency loop a number of times with the given precondition and given update functions using Python's \nnumpy.linalg.eigh\n (which hopefully is using MKL library).\n\n\nArguments\n\n\n\n\nsolver ::HFBSolver{T}\n\n\nsol::HFBSolution\n\n\nrun::Integer\n\n\n\n\nOptional Arguments\n\n\n\n\nupdate::Function=simpleupdate\n\n\nprecondition::Function=identity\n\n\ncallback::Function=_noop\n: Function called after every update as\n\n\n\n\ncallback(i, run)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.loopthreaded\n \n \nMethod\n.\n\n\nloop\n\n\n\n\n\nPerform selfconsistency loop a number of times with the given precondition and given update functions.\n\n\nArguments\n\n\n\n\nsolver ::HFBSolver{T}\n\n\nsol::HFBSolution\n\n\nrun::Integer\n\n\n\n\nOptional Arguments\n\n\n\n\nupdate::Function=simpleupdate\n\n\nprecondition::Function=identity\n\n\ncallback::Function=_noop\n: Function called after every update as\n\n\n\n\ncallback(i, run)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeDeltamatrix\n \n \nMethod\n.\n\n\nReturn a generator of \u0394 matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeGammamatrix\n \n \nMethod\n.\n\n\nReturn a generator of \u0393 matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makegreencollectors\n \n \nMethod\n.\n\n\nmakegreencollectors\n\n\n\n\n\nReturns a function which has the following signature\n\n\ncollector(k, eigenvalues, eigenvectors, \u03c1out, tout)\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makehamiltonian\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makehoppingmatrix\n \n \nMethod\n.\n\n\nReturn a generator of hopping matrix (which is a function of momentum)\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n \n \nMethod\n.\n\n\nfunc : (idx, i, j, r) -\n 0\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makesourcefields\n \n \nMethod\n.\n\n\nfunc : (idx, i, j, r) -\n val\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbhint\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n \n \nMethod\n.\n\n\nReturn a zero solution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.newhfbsolution\n \n \nMethod\n.\n\n\nCheck if hint contains \u03c1\n\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.randomize!\n \n \nMethod\n.\n\n\nRandomize a solution\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.CollectRow\n \n \nType\n.\n\n\nCollectRow\n is holds info on how to compute \u03c1 or t. Its elements are:\n\n\n\n\nIs diagonal? (only for rho)\n\n\nrow orbital\n\n\ncol orbital\n\n\ndisplacement r(col) - r(row)\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.DeployRow\n \n \nType\n.\n\n\nDeployRow\n is holds info on how to compute \u0393 or \u0394. Its elements are:\n\n\n\n\nIs diagonal\n\n\nrow orbital\n\n\ncol orbital\n\n\ndisplacement r(col) - r(row)\n\n\nlist of sources, each of which is a tuple of\n\n\nindex of \u03c1 or t from which to compute this \u0393 or \u0394.\n\n\namplitude (coefficient to multiply to \u03c1 or t)\n\n\nboolean indicating whether   (1) conjugation is needed (for \u03c1/\u0393) or   (2) minus sign is needed (for t/\u0394).\n\n\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.HoppingMeanField\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.PairingMeanField\n \n \nType\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeparticleholeregistry\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.makeparticleparticleregistry\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n#\n\n\nHartreeFockBogoliubov.HFB.nambufy\n \n \nMethod\n.\n\n\nsource\n\n\n\n\nLinearizedGap\n\n\n#\n\n\nHartreeFockBogoliubov.LinearizedGap.linearizedpairingkernel\n \n \nMethod\n.\n\n\nlinearizedpairingkernel\n\n\nCompute the kernel \u0393 of the linearized gap equation in the pairing channel which is written as \u0394 = \u0393\u22c5\u0394\n\n\nsource", 
            "title": "More"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#internals", 
            "text": "", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#lattice", 
            "text": "#  HartreeFockBogoliubov.Lattice.CarteCoord     Type .  CarteCoord  Cartesian coordinates.  Vector{Float64} .  source  #  HartreeFockBogoliubov.Lattice.FractCoord     Type .  FractCoord  Fractional coordinates.  Members   whole ::Vector{Int} : Integer part of fractional coordinates  fraction ::Vector{Float64} : [0,1) part of fractional coordinates   source  #  HartreeFockBogoliubov.Lattice.UnitCell     Type .  UnitCell{T}  Members   latticevectors ::Array{Float64, 2} : Lattice vectors  reducedreciprocallatticevectors ::Array{Float64, 2} : Reduced reciprocal lattice vectors (transpose of inverse of  latticevectors )  reciprocallatticevectors ::Array{Float64, 2} : Reciprocal lattice vectors  orbitals ::Vector{Tuple{T, FractCoord}} : List of orbitals within unit cell  orbitalindices ::Dict{T, Int} : Indices of orbitals   source  #  HartreeFockBogoliubov.Lattice.addorbital!     Method .  addorbital!  Add an orbital to the unit cell.  Arguments   uc ::UnitCell{T}  orbitalname ::{T}  orbitalcoord ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.carte2fract     Method .  carte2fract  Arguments   latticevectors ::Array{Float64, 2}  cc ::CarteCoord   source  #  HartreeFockBogoliubov.Lattice.carte2fract     Method .  carte2fract  Arguments   latticevectors ::Array{Float64, 2}  cc ::CarteCoord   source  #  HartreeFockBogoliubov.Lattice.dimension     Method .  dimension  Dimension of the fractional coordinates  Arguments   fc ::FractCoord : Fractional coordinates.   source  #  HartreeFockBogoliubov.Lattice.dimension     Method .  dimension  Spatial dimension of the unit cell.  source  #  HartreeFockBogoliubov.Lattice.fract2carte     Method .  fract2carte  Arguments   latticevectors ::Array{Float64, 2}  fc ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.fract2carte     Method .  fract2carte  Arguments   latticevectors ::Array{Float64, 2}  fc ::FractCoord   source  #  HartreeFockBogoliubov.Lattice.getorbital     Method .  getorbital  Arguments   uc ::UnitCell{T}  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.getorbital     Method .  getorbital  Get the orbital with the given name.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalcoord     Method .  getorbitalcoord  Arguments   uc ::UnitCell  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.getorbitalcoord     Method .  getorbitalcoord  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalindex     Method .  getorbitalindex  Get index of the given orbital.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.getorbitalindexcoord     Method .  getorbitalindexcoord  Arguments   uc ::UnitCell{T}  name ::T   source  #  HartreeFockBogoliubov.Lattice.getorbitalname     Method .  getorbitalname  Arguments   uc ::UnitCell  idx ::Integer   source  #  HartreeFockBogoliubov.Lattice.hasorbital     Method .  hasorbital{T}  Test whether the unit cell contains the orbital of given name.  Arguments   uc ::UnitCell{O}  name ::O   source  #  HartreeFockBogoliubov.Lattice.newunitcell     Method .  UnitCell  Arguments   latticevectors ::Array{Float64, 2} : Lattice vectors  OrbitalType::DataType   Optional Arguments   tol=sqrt(eps(Float64)) : Epsilon   source  #  HartreeFockBogoliubov.Lattice.newunitcell     Method .  UnitCell  Construct a one-dimensional lattice.  Arguments   latticeconstant ::Float64 : Lattice constant  OrbitalType : List of orbitals   Optional Arguments   tol=sqrt(eps(Float64)) : Tolerance   source  #  HartreeFockBogoliubov.Lattice.numorbital     Method .  numorbital  Number of orbitals of the unit cell.  Arguments   uc ::UnitCell   source  #  HartreeFockBogoliubov.Lattice.whichunitcell     Method .  whichunitcell  Return which unit cell the specificied orbital/cartesian coordinates belongs to.  source", 
            "title": "Lattice"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#spec", 
            "text": "#  HartreeFockBogoliubov.Spec     Module .  Submodule `Spec`  source  #  HartreeFockBogoliubov.Spec.Hopping     Constant .  Hopping  source  #  HartreeFockBogoliubov.Spec.Interaction     Constant .  Interaction  source  #  HartreeFockBogoliubov.Spec.FullHamiltonian     Type .  FullHamiltonian  Members   unitcell ::UnitCell  hoppings ::Vector{Hopping}  interactions ::Vector{Interaction}   source  #  HartreeFockBogoliubov.Spec.FullHamiltonian     Method .  Hamiltonian  Create an empty Hamiltonian  Arguments   unitcell ::UnitCell   source  #  HartreeFockBogoliubov.Spec.HoppingDiagonal     Type .  HoppingDiagonal{R :Real}  Represents   \n  t c_{i}^{*} c_{i}   Members   amplitude ::R  i ::Int : name of orbital  Ri ::Vector{Int} : which unit cell? (indexed by a1, and a2)   source  #  HartreeFockBogoliubov.Spec.HoppingDiagonal     Method .  source  #  HartreeFockBogoliubov.Spec.HoppingOffdiagonal     Type .  HoppingOffdiagonal{C :Number}  Represents   \n  t c_{i}^{*} c_{j} + t^* c_{j}^{*} c_{i}   Members   amplitude :: C  i ::T  j ::T  Ri ::Vector{Int}  Rj ::Vector{Int}   source  #  HartreeFockBogoliubov.Spec.InteractionDiagonal     Type .  InteractionDiagonal{R :Real}  Represents   \n    U c_{i}^{*} c_{j}^{*} c_{j} c_{i}   Members   amplitude ::R  i ::T  j ::T  Ri ::Vector{Int}  Rj ::Vector{Int}   source  #  HartreeFockBogoliubov.Spec.InteractionOffdiagonal     Type .  InteractionOffdiagonal{C :Number}\n\ni   j, k   l, i   k or (i == k and j   l)  Represents   \n   U     c_{i}^{*} c_{j}^{*} c_{l} c_{k}\n + U^{*} c_{k}^{*} c_{l}^{*} c_{j} c_{i}   Only keep the first term (and require i   j, k   l, i  = k)  Members   amplitude ::C  i ::T  j ::T  k ::T  l ::T  Ri ::Vector{Int}  Rj ::Vector{Int}  Rk ::Vector{Int}  Rl ::Vector{Int}   source  #  HartreeFockBogoliubov.Spec.addhopping!     Method .  addhopping!  Arguments   hamiltonian ::Hamiltonian  hopping ::HoppingOffdiagonal   source  #  HartreeFockBogoliubov.Spec.addhopping!     Method .  addhopping!  Arguments   hamiltonian ::Hamiltonian  hopping ::HoppingDiagonal   source  #  HartreeFockBogoliubov.Spec.addinteraction!     Method .  addinteraction!  Arguments   hamiltonian ::Hamiltonian  interaction ::InteractionOffdiagonal   source  #  HartreeFockBogoliubov.Spec.addinteraction!     Method .  addinteraction!  Arguments   hamiltonian ::Hamiltonian  interaction ::InteractionDiagonal   source  #  HartreeFockBogoliubov.Spec.hoppingbycarte     Method .  hoppingbycarte{T}  Arguments   uc ::UnitCell{T}  amplitude ::Number  i ::T  j ::T  ri ::CarteCoord  rj ::CarteCoord  tol ::Real  : Optional. Defaults to  sqrt(eps(Float64))   source  #  HartreeFockBogoliubov.Spec.hoppingbycarte     Method .  hoppingbycarte{T}  Arguments   uc ::UnitCell{T}  amplitude ::Real  i ::T  ri ::CarteCoord  tol ::Real  : Optional. Defaults to  sqrt(eps(Float64))   source  #  HartreeFockBogoliubov.Spec.interactionbycarte     Method .  interactionbycarte{T}  Arguments  * `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `k ::T`\n* `l ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `rk ::CarteCoord`\n* `rl ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`  source  #  HartreeFockBogoliubov.Spec.interactionbycarte     Method .  interactionbycarte{T}  Arguments  * `uc ::UnitCell{T}`\n* `amplitude ::Number`\n* `i ::T`\n* `j ::T`\n* `ri ::CarteCoord`\n* `rj ::CarteCoord`\n* `tol ::Real` : Optional. Defaults to `sqrt(eps(Float64))`  source", 
            "title": "Spec"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#generator", 
            "text": "#  HartreeFockBogoliubov.Generator     Module .  Generator submodule  source  #  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatefast     Method .  generatefast  source  #  HartreeFockBogoliubov.Generator.generatehoppingfast     Method .  generatefast  source", 
            "title": "Generator"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#topology", 
            "text": "#  HartreeFockBogoliubov.Topology.isvalidtimereversalmatrix     Method .  isvalidtimereversalmatrix  Test whether the given matrix is a valid unitary matrix for the time reversal operation.  ```math\nT = U \u22c5 K\n```\n\n``U`` must satisfy the two conditions:\n1. ``U U^{\\dagger} = 1`` (from unitarity of ``U``)\n2. ``U = - U^{\\mathsf{T}}`` (from `T^2 = -1`)  source  #  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  Arguments   uc::Spec.FullHamiltonian{O}   source  #  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  Arguments   uc::HFB.HFBHamiltonian{O}   source  #  HartreeFockBogoliubov.Topology.squarify     Method .  squarify  In order to make the Hamiltoinian a periodic function of momentum, bring all the sites to the origin. In addition, make the unitcell into a square.  Arguments   uc::Lattice.UnitCell{O}   source  #  HartreeFockBogoliubov.Topology.timereversalindexgrid     Method .  generate k-space grid (which has (2 n1, 2 n2) points TOTAL in the Brillouin zone)  Example  When n1 = 4, n2 = 3, this function returns an  OrderedDict  that represents the following structure  i2|\n  |\n5 | -i -i -i -i -i -i -i -i\n4 | -i -i -i -i -i -i -i -i\n3 | 0h +h +h +h 0h -h -h -h\n2 | +i +i +i +i +i +i +i +i\n1 | +i +i +i +i +i +i +i +i\n0 | 0z +z +z +z 0z -z -z -z\n--+----------------------------\n  |  0  1  2  3  4  5  6  7  i1  where 0z, +z, -z are represented respectively by  :TRIZERO ,  :POSZERO , and  :NEGZERO , and   0h, +h, -h by  :TRIHALF ,  :POSHALF , and  :NEGHALF , and   +i, -i by  :POSINT ,  :NEGINT .  source  #  HartreeFockBogoliubov.Topology.chernnumber     Method .  chernnumber  Compute chern number of the band structure defined by the hoppings and the selected bands.  source  #  HartreeFockBogoliubov.Topology.getnambuphase     Method .  Get the phase of hamiltonian function.     Returns nan if no phase  source  #  HartreeFockBogoliubov.Topology.z2index     Method .  z2index  Compute Z2 index of time-reversal-invariant Hamiltonian.  Arguments   uc::UnitCell{O}  hops::AbstractVector{Hopping}  timereversal::AbstractMatrix  n1 ::Integer  n2 ::Integer  selectpairs::AbstractVector{ :Integer}   Optional Arguments   tol ::Real = sqrt(eps(Float64))   Returns  (The Z2 index,  max| H\u2096 - T\u207b\u00b9H\u2096T | for k in TRIMs)  source", 
            "title": "Topology"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#hfb", 
            "text": "#  HartreeFockBogoliubov.HFB.HFBComputer     Type .  HFBConmputer  is a type holding the \u03c1, t and \u0393, \u0394 of a Hartree-Fock-Bogoliubov Hamiltonian.  source  #  HartreeFockBogoliubov.HFB.HFBComputer     Method .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Type .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.HFBHamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.HFBSolver     Type .  source  #  HartreeFockBogoliubov.HFB.HFBSolver     Method .  source  #  HartreeFockBogoliubov.HFB.addinteraction!     Method .  Add offdiagonal interaction  source  #  HartreeFockBogoliubov.HFB.addinteraction!     Method .  addinteraction!  Add diagonal interaction  source  #  HartreeFockBogoliubov.HFB.computetargetfields     Method .  Compute \u0393 and \u0394 from \u03c1 and t.  source  #  HartreeFockBogoliubov.HFB.fixhfbsolution     Method .  Recompute \u0393 and \u0394 from \u03c1 and t in a  HFBSolution  source  #  HartreeFockBogoliubov.HFB.freeze     Method .  freeze\n\nCreate a hopping hamiltonian out of HFB Hamiltonian and Solution\n\nOrder:\nelectrons......, HOLE......  source  #  HartreeFockBogoliubov.HFB.getnextsolution     Method .  source  #  HartreeFockBogoliubov.HFB.getnextsolutionpython     Method .  source  #  HartreeFockBogoliubov.HFB.getnextsolutionthreaded     Method .  source  #  HartreeFockBogoliubov.HFB.isvalidsolution     Method .  source  #  HartreeFockBogoliubov.HFB.loop     Method .  loop  Perform selfconsistency loop a number of times with the given precondition and given update functions.  Arguments   solver ::HFBSolver{T}  sol::HFBSolution  run::Integer   Optional Arguments   update::Function=simpleupdate  precondition::Function=identity  callback::Function=_noop : Function called after every update as   callback(i, run)  source  #  HartreeFockBogoliubov.HFB.looppython     Method .  loop  Perform selfconsistency loop a number of times with the given precondition and given update functions using Python's  numpy.linalg.eigh  (which hopefully is using MKL library).  Arguments   solver ::HFBSolver{T}  sol::HFBSolution  run::Integer   Optional Arguments   update::Function=simpleupdate  precondition::Function=identity  callback::Function=_noop : Function called after every update as   callback(i, run)  source  #  HartreeFockBogoliubov.HFB.loopthreaded     Method .  loop  Perform selfconsistency loop a number of times with the given precondition and given update functions.  Arguments   solver ::HFBSolver{T}  sol::HFBSolution  run::Integer   Optional Arguments   update::Function=simpleupdate  precondition::Function=identity  callback::Function=_noop : Function called after every update as   callback(i, run)  source  #  HartreeFockBogoliubov.HFB.makeDeltamatrix     Method .  Return a generator of \u0394 matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makeGammamatrix     Method .  Return a generator of \u0393 matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makegreencollectors     Method .  makegreencollectors  Returns a function which has the following signature  collector(k, eigenvalues, eigenvectors, \u03c1out, tout)  source  #  HartreeFockBogoliubov.HFB.makehamiltonian     Method .  source  #  HartreeFockBogoliubov.HFB.makehoppingmatrix     Method .  Return a generator of hopping matrix (which is a function of momentum)  source  #  HartreeFockBogoliubov.HFB.makesourcefields     Method .  func : (idx, i, j, r) -  0  source  #  HartreeFockBogoliubov.HFB.makesourcefields     Method .  func : (idx, i, j, r) -  val  source  #  HartreeFockBogoliubov.HFB.newhfbhint     Method .  source  #  HartreeFockBogoliubov.HFB.newhfbsolution     Method .  Return a zero solution  source  #  HartreeFockBogoliubov.HFB.newhfbsolution     Method .  Check if hint contains \u03c1  source  #  HartreeFockBogoliubov.HFB.randomize!     Method .  Randomize a solution  source  #  HartreeFockBogoliubov.HFB.CollectRow     Type .  CollectRow  is holds info on how to compute \u03c1 or t. Its elements are:   Is diagonal? (only for rho)  row orbital  col orbital  displacement r(col) - r(row)   source  #  HartreeFockBogoliubov.HFB.DeployRow     Type .  DeployRow  is holds info on how to compute \u0393 or \u0394. Its elements are:   Is diagonal  row orbital  col orbital  displacement r(col) - r(row)  list of sources, each of which is a tuple of  index of \u03c1 or t from which to compute this \u0393 or \u0394.  amplitude (coefficient to multiply to \u03c1 or t)  boolean indicating whether   (1) conjugation is needed (for \u03c1/\u0393) or   (2) minus sign is needed (for t/\u0394).   source  #  HartreeFockBogoliubov.HFB.HoppingMeanField     Type .  source  #  HartreeFockBogoliubov.HFB.PairingMeanField     Type .  source  #  HartreeFockBogoliubov.HFB.makeparticleholeregistry     Method .  source  #  HartreeFockBogoliubov.HFB.makeparticleparticleregistry     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source  #  HartreeFockBogoliubov.HFB.nambufy     Method .  source", 
            "title": "HFB"
        }, 
        {
            "location": "/internals/hartreefockbogoliubov/#linearizedgap", 
            "text": "#  HartreeFockBogoliubov.LinearizedGap.linearizedpairingkernel     Method .  linearizedpairingkernel  Compute the kernel \u0393 of the linearized gap equation in the pairing channel which is written as \u0394 = \u0393\u22c5\u0394  source", 
            "title": "LinearizedGap"
        }
    ]
}